src\main\java\com\example\authorization\SecurityAuthorizeApplication.java
package com.example.authorization;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SecurityAuthorizeApplication {

	public static void main(String[] args) {
		SpringApplication.run(SecurityAuthorizeApplication.class, args);
	}

}


src\main\java\com\example\authorization\config\AuthorizationServerConfiguration.java
package com.example.authorization.config;

import com.example.authorization.dto.ApiResponseStatus;
import com.example.authorization.dto.BaseResponseDto;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.nimbusds.jose.jwk.source.ImmutableSecret;
import com.nimbusds.jose.proc.SecurityContext;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import com.nimbusds.jose.jwk.source.JWKSource;
import javax.crypto.SecretKey;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.security.authentication.InsufficientAuthenticationException;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.oauth2.server.authorization.oidc.authentication.OidcLogoutAuthenticationToken;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.oauth2.server.authorization.client.RegisteredClientRepository;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.server.authorization.config.annotation.web.configuration.OAuth2AuthorizationServerConfiguration;
import org.springframework.security.oauth2.server.authorization.config.annotation.web.configurers.OAuth2AuthorizationServerConfigurer;
import org.springframework.security.oauth2.server.authorization.settings.AuthorizationServerSettings;
import org.springframework.security.oauth2.server.authorization.token.JwtEncodingContext;
import org.springframework.security.oauth2.server.authorization.token.OAuth2TokenCustomizer;
import org.springframework.security.web.authentication.AuthenticationConverter;
import org.springframework.security.web.authentication.AuthenticationFailureHandler;
import org.springframework.security.web.authentication.AuthenticationSuccessHandler;
import org.springframework.util.StringUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;

import static org.springframework.security.oauth2.server.authorization.OAuth2TokenType.ACCESS_TOKEN;

@Configuration
@RequiredArgsConstructor
public class AuthorizationServerConfiguration {

    private final RegisteredClientRepository registeredClientRepository;
    private final SecretKey jwtSecretKey;

    public static class OidcLogoutRequestConverter implements AuthenticationConverter {
        @Override
        public Authentication convert(HttpServletRequest request) {
            String idTokenHint = request.getParameter("id_token_hint");
            String postLogoutRedirectUri = request.getParameter("post_logout_redirect_uri");
            String state = request.getParameter("state");
            String sessionId = request.getParameter("session_id");
            String clientId = request.getParameter("client_id");

            Authentication principal = SecurityContextHolder.getContext().getAuthentication();
            if (principal == null) {
                throw new InsufficientAuthenticationException("濡쒓렇???곹깭媛 ?꾨떃?덈떎.");
            }

            if (!StringUtils.hasText(idTokenHint)) {
                throw new IllegalArgumentException("id_token_hint ?뚮씪誘명꽣媛 ?꾨씫?섏뿀?듬땲??");
            }

            return new OidcLogoutAuthenticationToken(
                    idTokenHint,
                    principal,
                    sessionId,
                    clientId,
                    postLogoutRedirectUri,
                    state
            );
        }
    }

    public static class OidcLogoutSuccessHandler implements AuthenticationSuccessHandler {
        @Override
        public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
                                            Authentication authentication) throws IOException, ServletException {
            response.sendRedirect("/logout-success");
        }
    }

    public static class OidcLogoutFailureHandler implements AuthenticationFailureHandler {
        private final ObjectMapper objectMapper = new ObjectMapper();
        @Override
        public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response,
                                            AuthenticationException exception) throws IOException, ServletException {
            BaseResponseDto<String> errorResponse = new BaseResponseDto<>(ApiResponseStatus.INVALID_CREDENTIALS, exception.getMessage());
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.setContentType("application/json");
            String jsonResponse = objectMapper.writeValueAsString(errorResponse);
            response.getWriter().write(jsonResponse);
        }
    }

    @Bean
    @Order(Ordered.HIGHEST_PRECEDENCE)
    public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {
        OAuth2AuthorizationServerConfigurer authorizationServerConfigurer =
                OAuth2AuthorizationServerConfigurer.authorizationServer();
        authorizationServerConfigurer.registeredClientRepository(registeredClientRepository);
        http
                .securityMatcher(authorizationServerConfigurer.getEndpointsMatcher())
                .with(authorizationServerConfigurer, (authorizationServer) ->
                        authorizationServer
                                .oidc(Customizer.withDefaults())
                );

        http.exceptionHandling(exceptions ->
                exceptions.authenticationEntryPoint(
                        new org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint("/login")
                )
        );

        http
                .securityMatcher(authorizationServerConfigurer.getEndpointsMatcher())
                .with(authorizationServerConfigurer, (authorizationServer) -> authorizationServer
                        .oidc(oidc -> oidc
                                .logoutEndpoint(logoutEndpoint -> logoutEndpoint
                                        .logoutRequestConverter(new OidcLogoutRequestConverter())
                                        .logoutResponseHandler(new OidcLogoutSuccessHandler())
                                        .errorResponseHandler(new OidcLogoutFailureHandler())
                                )
                        )
                );
        return http.build();
    }

    @Bean
    @Order(Ordered.LOWEST_PRECEDENCE)
    public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
        http
                .authorizeHttpRequests(auth -> auth.anyRequest().authenticated())
                .formLogin(Customizer.withDefaults());
        return http.build();
    }

    @Bean
    public JWKSource<SecurityContext> jwkSource() {
        return new ImmutableSecret<>(jwtSecretKey);
    }

    @Bean
    public JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) {
        return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource);
    }

    @Bean
    public AuthorizationServerSettings authorizationServerSettings() {
        return AuthorizationServerSettings.builder()
                .issuer("http://localhost:8081")
                .build();
    }

    @Bean
    public OAuth2TokenCustomizer<JwtEncodingContext> tokenCustomizer() {
        return context -> {
            if (ACCESS_TOKEN.equals(context.getTokenType())) {
                var principal = context.getPrincipal();
                var authorities = principal.getAuthorities();
                context.getClaims().claim("roles", authorities.stream()
                        .map(auth -> auth.getAuthority().replace("ROLE_", ""))
                        .toList());
            }
        };
    }
}


src\main\java\com\example\authorization\config\CustomRegisteredClientRepository.java
package com.example.authorization.config;

import com.example.authorization.model.entity.Client;
import com.example.authorization.repository.ClientRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.oauth2.core.AuthorizationGrantType;
import org.springframework.security.oauth2.core.ClientAuthenticationMethod;
import org.springframework.security.oauth2.server.authorization.client.RegisteredClient;
import org.springframework.security.oauth2.server.authorization.client.RegisteredClientRepository;
import org.springframework.security.oauth2.server.authorization.settings.ClientSettings;
import org.springframework.security.oauth2.server.authorization.settings.TokenSettings;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.time.Duration;

@Component
@RequiredArgsConstructor
public class CustomRegisteredClientRepository implements RegisteredClientRepository {

    private final ClientRepository clientRepository;

    @Transactional
    @Override
    public void save(RegisteredClient registeredClient) {
        Client client = Client.builder()
                .clientId(registeredClient.getClientId())
                .clientSecret(registeredClient.getClientSecret())
                .redirectUri(String.join(",", registeredClient.getRedirectUris()))
                .scopes(String.join(",", registeredClient.getScopes()))
                .grantTypes(registeredClient.getAuthorizationGrantTypes().stream()
                        .map(AuthorizationGrantType::getValue)
                        .reduce((a, b) -> a + "," + b).orElse(""))
                .accessTokenTtl((int) registeredClient.getTokenSettings().getAccessTokenTimeToLive().toSeconds())
                .refreshTokenTtl((int) registeredClient.getTokenSettings().getRefreshTokenTimeToLive().toSeconds())
                .build();

        clientRepository.save(client);
    }

    @Override
    public RegisteredClient findById(String id) {
        return clientRepository.findById(Long.parseLong(id))
                .map(this::convertToRegisteredClient)
                .orElse(null);
    }

    @Override
    public RegisteredClient findByClientId(String clientId) {
        return clientRepository.findByClientId(clientId)
                .map(this::convertToRegisteredClient)
                .orElse(null);
    }

    private RegisteredClient convertToRegisteredClient(Client client) {
        return RegisteredClient.withId(client.getId().toString())
                .clientId(client.getClientId())
                .clientSecret(client.getClientSecret())
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                .redirectUri(client.getRedirectUri())
                .scope(client.getScopes())
                .tokenSettings(TokenSettings.builder()
                        .accessTokenTimeToLive(Duration.ofSeconds(client.getAccessTokenTtl()))
                        .refreshTokenTimeToLive(Duration.ofSeconds(client.getRefreshTokenTtl()))
                        .build())
                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(true).build())
                .build();
    }
}


src\main\java\com\example\authorization\config\JwtConfig.java
package com.example.authorization.config;

import java.nio.charset.StandardCharsets;

import javax.crypto.SecretKey;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import io.jsonwebtoken.security.Keys;

@Configuration
public class JwtConfig {

    @Value("${jwt.secret}")
    private String jwtSecret;

    @Bean
    public SecretKey jwtSecretKey() {
        return Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));
    }
}


src\main\java\com\example\authorization\config\RedisConfig.java
package com.example.authorization.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;

@Configuration
public class RedisConfig {

    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        // 湲곕낯?곸쑝濡?localhost:6379 ?ъ슜
        return new LettuceConnectionFactory();
    }

    @Bean
    public RedisTemplate<String, String> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, String> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);
        return template;
    }
}


src\main\java\com\example\authorization\config\WebSecurityConfig.java
package com.example.authorization.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import com.example.authorization.security.JwtAuthenticationFilter;

@Configuration
public class WebSecurityConfig {
    @Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http, JwtAuthenticationFilter jwtAuthenticationFilter) throws Exception {
    http
    .csrf(AbstractHttpConfigurer::disable)
    .authorizeHttpRequests(authorizeRequests ->
        authorizeRequests
            .requestMatchers("/auth/login", "/auth/refresh", "/clients/register").permitAll()
            .anyRequest().authenticated()
    )
    .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
    return http.build();
}


    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}


src\main\java\com\example\authorization\controller\AuthController.java
package com.example.authorization.controller;

import com.example.authorization.dto.*;
import com.example.authorization.model.entity.User;
import com.example.authorization.repository.UserRepository;
import com.example.authorization.service.AuthService;
import com.example.authorization.service.TokenService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.*;

import java.util.Optional;

@RestController
@RequestMapping("/auth")
@RequiredArgsConstructor
public class AuthController {

    private final UserRepository userRepository;
    private final TokenService tokenService;
    private final PasswordEncoder passwordEncoder;
    private final AuthService authService;

    @PostMapping("/login")
    public ResponseEntity<BaseResponseDto<TokenResponse>> login(@RequestBody LoginRequest request) {
        return ResponseEntity.ok(new BaseResponseDto<>(ApiResponseStatus.SUCCESS, authService.login(request)));
    }

    @PostMapping("/refresh")
    public ResponseEntity<BaseResponseDto<TokenResponse>> refresh(@RequestBody RefreshRequest request) {
        return ResponseEntity.ok(new BaseResponseDto<>(ApiResponseStatus.SUCCESS, authService.refresh(request)));
    }

    @PostMapping("/clients/register")
    public ResponseEntity<BaseResponseDto<RegisterResponse>> registerClient(@RequestBody RegisterRequest request) {
        // TODO: ?ㅼ젣 ?대씪?댁뼵???깅줉 濡쒖쭅 援ы쁽
        return ResponseEntity.ok(new BaseResponseDto<>(ApiResponseStatus.SUCCESS, new RegisterResponse("client_id", "client_secret")));
    }
}


src\main\java\com\example\authorization\dto\ApiResponseStatus.java
package com.example.authorization.dto;

import lombok.Getter;

@Getter
public enum ApiResponseStatus {
    SUCCESS("200", "Login successful"),
    INVALID_CREDENTIALS("401", "Invalid credentials");

    private final String code;
    private final String message;

    ApiResponseStatus(String code, String message) {
        this.code = code;
        this.message = message;
    }

}


src\main\java\com\example\authorization\dto\BaseResponseDto.java
package com.example.authorization.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class BaseResponseDto<T> {
    private ApiResponseStatus status;
    private T data;
}


src\main\java\com\example\authorization\dto\LoginRequest.java
package com.example.authorization.dto;

public record LoginRequest(String email, String password) {}


src\main\java\com\example\authorization\dto\RefreshRequest.java
package com.example.authorization.dto;

public record RefreshRequest(String refreshToken) {
}


src\main\java\com\example\authorization\dto\RegisterRequest.java
package com.example.authorization.dto;

public record RegisterRequest() {
}


src\main\java\com\example\authorization\dto\RegisterResponse.java
package com.example.authorization.dto;

public record RegisterResponse(String clientId, String clientSecret) {
}


src\main\java\com\example\authorization\dto\ResponseStatus.java
package com.example.authorization.dto;

public enum ResponseStatus {
    SUCCESS,
    FAIL,
    ERROR,
    UNAUTHORIZED
}


src\main\java\com\example\authorization\dto\TokenResponse.java
package com.example.authorization.dto;

public record TokenResponse(String accessToken, String refreshToken) {}


src\main\java\com\example\authorization\exception\GlobalExceptionHandler.java
package com.example.authorization.exception;

import com.example.authorization.dto.ApiResponseStatus;
import com.example.authorization.dto.BaseResponseDto;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(InvalidCredentialsException.class)
    public ResponseEntity<BaseResponseDto<Object>> handleInvalidCredentialsException(InvalidCredentialsException ex) {
        BaseResponseDto<Object> response = new BaseResponseDto<>(ApiResponseStatus.INVALID_CREDENTIALS, null);
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
    }

    // ?꾩슂???곕씪 ?ㅻⅨ ?덉쇅 ?몃뱾?щ뱾??異붽??????덉뒿?덈떎.
}


src\main\java\com\example\authorization\exception\InvalidCredentialsException.java
package com.example.authorization.exception;

public class InvalidCredentialsException extends RuntimeException {
    public InvalidCredentialsException(String message) {
        super(message);
    }
}


src\main\java\com\example\authorization\model\entity\BaseEntity.java
package com.example.authorization.model.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Getter
@Setter
@MappedSuperclass
public abstract class BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = createdAt;
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}


src\main\java\com\example\authorization\model\entity\Client.java
package com.example.authorization.model.entity;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "clients")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@Builder
public class Client extends BaseEntity {
    @Column(nullable = false, unique = true)
    private String clientId;

    @Column(nullable = false)
    private String clientSecret;

    @Column(nullable = false)
    private String redirectUri;

    @Column(nullable = false)
    private String scopes; // ?쇳몴(,)濡?援щ텇???ㅼ퐫??紐⑸줉

    @Column(nullable = false)
    private String grantTypes; // ?쇳몴(,)濡?援щ텇???몄쬆 諛⑹떇

    @Column(nullable = false)
    private int accessTokenTtl; // Access Token ?좏슚?쒓컙(珥?

    @Column(nullable = false)
    private int refreshTokenTtl; // Refresh Token ?좏슚?쒓컙(珥?
}


src\main\java\com\example\authorization\model\entity\User.java
package com.example.authorization.model.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import java.util.Collection;
import java.util.List;
import org.springframework.security.core.authority.SimpleGrantedAuthority;

@Entity
@Table(name = "users")
@Getter
@Setter
public class User extends BaseEntity implements UserDetails {
    
    @Column(nullable = false, unique = true)
    private String email; // 濡쒓렇???꾩씠?붾줈 ?ъ슜
    
    @Column(nullable = false)
    private String password;
    
    // roles ?꾨뱶??肄ㅻ쭏濡?援щ텇??臾몄옄??(?? "ROLE_USER,ROLE_ADMIN")
    @Column(nullable = false)
    private String roles;
    
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        String[] roleArray = roles.split(",");
        return List.of(roleArray).stream()
                .map(String::trim)
                .map(SimpleGrantedAuthority::new)
                .toList();
    }
    
    @Override
    public String getUsername() {
        return email;
    }
    
    // ?꾨옒 UserDetails 硫붿꽌?쒕뱾? 紐⑤몢 true濡?泥섎━ (?꾩슂 ??濡쒖쭅 異붽?)
    @Override public boolean isAccountNonExpired() { return true; }
    @Override public boolean isAccountNonLocked() { return true; }
    @Override public boolean isCredentialsNonExpired() { return true; }
    @Override public boolean isEnabled() { return true; }
}


src\main\java\com\example\authorization\repository\ClientRepository.java
package com.example.authorization.repository;

import com.example.authorization.model.entity.Client;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface ClientRepository extends JpaRepository<Client, Long> {
    Optional<Client> findByClientId(String clientId);
}


src\main\java\com\example\authorization\repository\UserRepository.java
package com.example.authorization.repository;

import org.springframework.data.jpa.repository.JpaRepository;

import com.example.authorization.model.entity.User;

import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
}


src\main\java\com\example\authorization\security\JwtAuthenticationFilter.java
package com.example.authorization.security;

import com.example.authorization.service.TokenService;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import lombok.RequiredArgsConstructor;

import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;

import javax.crypto.SecretKey;

@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final TokenService tokenService;
    private final UserDetailsService userDetailsService;
    private final SecretKey secretKey;

    @Override
    protected void doFilterInternal(@NonNull HttpServletRequest request, @NonNull HttpServletResponse response, @NonNull FilterChain filterChain)
            throws ServletException, IOException {
        String token = request.getHeader("Authorization");

        if (token != null && token.startsWith("Bearer ")) {
            token = token.substring(7);

            if (tokenService.validateToken(token)) {
                Claims claims = Jwts.parser()
                        .verifyWith(secretKey)
                        .build()
                        .parseSignedClaims(token)
                        .getPayload();

                String email = claims.getSubject();
                UserDetails userDetails = userDetailsService.loadUserByUsername(email);

                UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        }

        filterChain.doFilter(request, response);
    }
}


src\main\java\com\example\authorization\service\AuthService.java
package com.example.authorization.service;

import com.example.authorization.dto.LoginRequest;
import com.example.authorization.dto.RefreshRequest;
import com.example.authorization.dto.TokenResponse;
import com.example.authorization.exception.InvalidCredentialsException;
import com.example.authorization.model.entity.User;
import com.example.authorization.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.util.Optional;

// AuthService.java - ?좉퇋 ?앹꽦 (鍮꾩쫰?덉뒪 濡쒖쭅 遺꾨━)
@Service
@RequiredArgsConstructor
public class AuthService {

    private final UserRepository userRepository;
    private final TokenService tokenService;
    private final PasswordEncoder passwordEncoder;

    public TokenResponse login(LoginRequest request) {
        Optional<User> userOptional = userRepository.findByEmail(request.email());
        if (userOptional.isEmpty() || !passwordEncoder.matches(request.password(), userOptional.get().getPassword())) {
            // ?덉쇅 泥섎━ ?먮뒗 蹂꾨룄 ?먮윭 泥섎━瑜??듯빐 而⑦듃濡ㅻ윭?먯꽌 ?숈씪???묐떟??以????덈룄濡???
            throw new InvalidCredentialsException("Invalid credentials");
        }
        User user = userOptional.get();
        String accessToken = tokenService.generateAccessToken(user.getEmail());
        String refreshToken = tokenService.generateRefreshToken(user.getEmail());
        tokenService.saveTokens(accessToken, refreshToken);
        return new TokenResponse(accessToken, refreshToken);
    }

    public TokenResponse refresh(RefreshRequest request) {
        if (!tokenService.isValidRefreshToken(request.refreshToken())) {
            throw new InvalidCredentialsException("Invalid credentials");
        }
        Optional<User> userOptional = tokenService.getUserFromRefreshToken(request.refreshToken());
        if (userOptional.isEmpty()) {
            throw new InvalidCredentialsException("Invalid credentials");
        }
        User user = userOptional.get();
        String accessToken = tokenService.generateAccessToken(user.getEmail());
        String refreshToken = tokenService.generateRefreshToken(user.getEmail());
        tokenService.saveTokens(accessToken, refreshToken);
        return new TokenResponse(accessToken, refreshToken);
    }
}


src\main\java\com\example\authorization\service\ClientService.java
package com.example.authorization.service;

import com.example.authorization.model.entity.Client;
import com.example.authorization.repository.ClientRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.Optional;

@Service
@RequiredArgsConstructor
public class ClientService {

    private final ClientRepository clientRepository;

    public Optional<Client> findByClientId(String clientId) {
        return clientRepository.findByClientId(clientId);
    }
}


src\main\java\com\example\authorization\service\CustomUserDetailsService.java
package com.example.authorization.service;

import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import com.example.authorization.repository.UserRepository;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class CustomUserDetailsService implements UserDetailsService {
    private final UserRepository userRepository;
    
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // username? email濡??ъ슜??        return userRepository.findByEmail(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));
    }
}


src\main\java\com\example\authorization\service\TokenService.java
package com.example.authorization.service;

import com.example.authorization.model.entity.User;
import com.example.authorization.repository.UserRepository;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import lombok.RequiredArgsConstructor;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;
import java.util.Date;
import java.util.Optional;
import java.util.concurrent.TimeUnit;
import javax.crypto.SecretKey;

@Service
@RequiredArgsConstructor
public class TokenService {

    private final StringRedisTemplate redisTemplate;
    private final UserRepository userRepository;
    private final SecretKey secretKey;

    private static final long ACCESS_TOKEN_EXPIRY = 24 * 60 * 60 * 1000; // 24?쒓컙
    private static final long REFRESH_TOKEN_EXPIRY = 7 * 24 * 60 * 60 * 1000; // 7??

    public String generateAccessToken(String email) {
        return Jwts.builder()
                .subject(email)
                .issuedAt(new Date())
                .expiration(new Date(System.currentTimeMillis() + ACCESS_TOKEN_EXPIRY))
                .signWith(secretKey)
                .compact();
    }

    public String generateRefreshToken(String email) {
        return Jwts.builder()
                .subject(email)
                .issuedAt(new Date())
                .expiration(new Date(System.currentTimeMillis() + REFRESH_TOKEN_EXPIRY))
                .signWith(secretKey)
                .compact();
    }

    public void saveTokens(String accessToken, String refreshToken) {
        redisTemplate.opsForValue().set(accessToken, refreshToken, REFRESH_TOKEN_EXPIRY, TimeUnit.MILLISECONDS);
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parser()
                .verifyWith(secretKey).
                build().parseSignedClaims(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    public boolean isValidRefreshToken(String refreshToken) {
        try {
            Jwts.parser()
                    .verifyWith(secretKey)
                    .build()
                    .parseSignedClaims(refreshToken);
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    public Optional<User> getUserFromRefreshToken(String refreshToken) {
        try {
            Claims claims = Jwts.parser()
                    .verifyWith(secretKey)
                    .build().parseSignedClaims(refreshToken).getPayload();
            String email = claims.getSubject();
            return userRepository.findByEmail(email);
        } catch (Exception e) {
            return Optional.empty();
        }
    }

    public String getRefreshToken(String accessToken) {
        return redisTemplate.opsForValue().get(accessToken);
    }

    public void deleteTokens(String accessToken) {
        redisTemplate.delete(accessToken);
    }
}


src\main\java\com\example\authorization\service\UserService.java
package com.example.authorization.service;

import com.example.authorization.model.entity.User;
import com.example.authorization.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;

    public User loadUserByEmail(String email) {
        return userRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with email: " + email));
    }
}


